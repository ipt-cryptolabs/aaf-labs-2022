Варіант №15: Колекція числових множин на основі інвертованого індексу

В даному варіанті передбачається, що по створеним колекціям будуються інвертовані індекси (inverted index), які використовуються для прискорення виконання пошукових команд. В якості елементів такого індексу виступають елементи множин, з яких складається колекція.
Перелік команд, які необхідно реалізувати:
CREATE collection_name; - створення нової колекції з назвою collection_name. В якості результату команда повинна повертати певне повідомлення для користувача, наприклад “Collection collection_name has been created”.

Приклад:
CREATE grades;

INSERT collection_name {val_1, val_2, ..., val_N}; - додавання нової множини з елементами val_1, val_2, …, val_N до колекції collection_name. Можна вважати, що всі елементи множини є унікальними, тобто зустрічаються у фігурних дужках рівно один раз. В якості результату команда повертати певне повідомлення для користувача, наприклад “Set has been added to collection_name”.

Приклад:
INSERT grades {90, 85, 95};

PRINT_INDEX collection_name; - виведення на екран внутрішньої структури інвертованого індексу, побудованого для колекції collection_name. Вивід повинен включати елементи та множини, яким вони належать.

Приклад:
Для індексу, що містить множини {1, 2, 3}, {4, 5} та {1, 4}, яким було присвоєно ідентифікатори s1, s2 та s3 відповідно, вивід повинен бути схожим до наступного:

1: s1, s3
2: s1
3: s1
4: s2, s3
5: s2

CONTAINS collection_name {val_1, val_2, ..., val_N}; - перевірка входження множини до колекції collection_name. В якості результату команда повинна повертати TRUE, якщо множина входить до колекції та FALSE, якщо ні. Зверніть увагу, що оскільки ми працюємо із множинами, то порядок елементів у фігурних дужках не повинен впливати на результат.

Приклад:
CONTAINS grades {90, 85, 95};

SEARCH collection*name *[WHERE query]; - пошук множин у колекції collection*name.
В основній частині завдання команда має форму SEARCH collection_name; і повинна просто повернути всі множини зі вказаної колекції. Додаткова частина (*) передбачає підтримку ключового слова WHERE та слідуючого за ним пошукового запиту. В цьому випадку команда повинна включити до вибірки тільки ті множини, які задовольняють даний запит. Визначення запиту query має наступний вигляд:
query := INTERSECTS {val_1, ..., val_N}
| CONTAINS {val_1, ..., val_N}
| CONTAINED_BY {val_1, ..., val_N}
Пояснення:
INTERSECTS {val_1, ..., val_N} - до вибірки повинні бути включені множини, які мають спільні елементи із множиною {val_1, ..., val_N}.
CONTAINS {val_1, ..., val_N} - до вибірки повинні бути включені множини, які включають в себе множину {val_1, ..., val_N}, тобто містять всі її елементи.
CONTAINED_BY {val_1, ..., val_N} - до вибірки повинні бути включені множини, які є підмножинами множини {val_1, ..., val_N}.

    В якості результату команда повинна повертати список знайдених множин. Порядок рядків може бути довільним.

Приклади команд:
SEARCH grades;
SEARCH grades WHERE INTERSECTS {82, 90, 92};
SEARCH grades WHERE CONTAINS {85, 90};
SEARCH grades WHERE CONTAINED_BY {75, 80, 85, 90, 95, 100};
